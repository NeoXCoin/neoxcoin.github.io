<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>NeoX Mini Demo – Scoring Test</title>
<style>
  :root {
    --bg:#0a0a2a; --fg:#fff; --gold:#ffd54a; --blue:#7ecbff; --bad:#ff5a5a;
    --ui:#ffffff20; --ui2:#ffffff35;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui, Arial, sans-serif;}
  .wrap{position:relative;max-width:700px;margin:0 auto;height:100dvh;display:flex;flex-direction:column;gap:8px;padding:8px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .score, .timer {font-weight:700}
  .btn{background:var(--ui2);border:1px solid var(--ui);padding:6px 10px;border-radius:8px;color:#fff}
  .btn:active{transform:translateY(1px)}
  #game{flex:1;position:relative;border:1px solid var(--ui);border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#10214e,#07112b);}
  /* on-screen controls for mobile */
  .ctrls{display:flex;gap:8px;justify-content:center;margin-top:8px}
  .ctrls .btn{min-width:90px;font-size:16px}
  /* video overlay */
  #endOverlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:#000;}
  #endVideo{width:100%;height:100%;object-fit:cover}
  /* canvas fills game */
  canvas{position:absolute;inset:0;width:100%;height:100%}
  /* tip */
  .tips{font-size:12px;opacity:.8;text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="score">Score: <span id="score">0</span></div>
    <button id="startBtn" class="btn">Start</button>
    <div class="timer">Time: <span id="time">60</span>s</div>
  </header>

  <div id="game">
    <canvas id="cv" width="700" height="420"></canvas>
    <div id="endOverlay">
      <video id="endVideo" src="NeoX_End_Game_VictoryGlow.mp4"></video>
    </div>
  </div>

  <div class="ctrls">
    <button class="btn" id="leftBtn">← Left</button>
    <button class="btn" id="rightBtn">Right →</button>
  </div>

  <div class="tips">操作：鍵盤 ← → 或點按畫面下方按鈕。接到🪙+10、💎+50；漏接會扣分；接到🔥會扣20。</div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');
  const startBtn = document.getElementById('startBtn');
  const endOverlay = document.getElementById('endOverlay');
  const endVideo = document.getElementById('endVideo');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');

  // Responsive canvas (keeps aspect, fits container)
  const fitCanvas = () => {
    const rect = cv.parentElement.getBoundingClientRect();
    const aspect = cv.width / cv.height;
    let w = rect.width, h = rect.height;
    if (w/h > aspect) w = h*aspect; else h = w/aspect;
    cv.style.width = w+'px'; cv.style.height = h+'px';
  };
  new ResizeObserver(fitCanvas).observe(document.getElementById('game')); fitCanvas();

  // Game state
  let running = false, t0=0, last=0, timer=60, score=0;
  const player = { x: cv.width/2, y: cv.height-36, w:60, h:18, speed:360, vx:0 };
  const coins = [];
  const keys = {left:false, right:false};
  let spawnAcc = 0;

  // Coin factory
  function spawnCoin() {
    // type weights: normal 60%, special 25%, fake 15%
    const r = Math.random();
    let type = 'normal';
    if (r>0.85) type='fake'; else if (r>0.60) type='special';
    const baseSpeed = {normal:120, special:180, fake:160}[type];
    coins.push({
      x: Math.random()*(cv.width-24)+12,
      y: -20,
      r: 14,
      vy: baseSpeed + Math.random()*60,
      type,
      caught:false
    });
  }

  // Drawing helpers
  function drawBackground(){
    // simple stars/gradient already via CSS; add faint horizon shine
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, cv.height-80, cv.width, 2);
  }
  function drawPlayer(){
    // Cute cartoony catcher bar
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = '#2ee6ff';
    ctx.shadowColor = '#7ecbff'; ctx.shadowBlur = 12;
    ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'white';
    ctx.fillRect(-player.w/2+6, -player.h/2+4, player.w-12, player.h-8);
    ctx.restore();
  }
  function drawCoin(c){
    ctx.save();
    ctx.translate(c.x, c.y);
    // glow
    ctx.shadowBlur = 15;
    if (c.type==='normal'){ ctx.shadowColor = '#ffd54a'; ctx.fillStyle = '#ffd54a'; }
    else if (c.type==='special'){ ctx.shadowColor = '#7ecbff'; ctx.fillStyle = '#7ecbff'; }
    else { ctx.shadowColor = '#ff5a5a'; ctx.fillStyle = '#ff5a5a'; }
    // coin body
    ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fill();
    // rim
    ctx.shadowBlur = 0; ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,.65)';
    ctx.stroke();
    // N mark (simple N as NeoX coin placeholder)
    ctx.fillStyle = 'rgba(0,0,0,.35)'; ctx.font = 'bold 14px system-ui';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('N', 0, 0);
    ctx.restore();
  }

  // Collision
  function intersects(c, p){
    const nearestX = Math.max(p.x - p.w/2, Math.min(c.x, p.x + p.w/2));
    const nearestY = Math.max(p.y - p.h/2, Math.min(c.y, p.y + p.h/2));
    const dx = c.x - nearestX, dy = c.y - nearestY;
    return (dx*dx + dy*dy) <= c.r*c.r;
  }

  // Scoring rules
  function onCatch(type){
    if (type==='normal') score += 10;
    else if (type==='special') score += 50;
    else if (type==='fake') score -= 20;
    updateUI();
  }
  function onMiss(type){
    if (type==='normal') score -= 5;
    else if (type==='special') score -= 10;
    // fake: no miss penalty
    updateUI();
  }
  function updateUI(){
    if (score < 0) score = 0;
    scoreEl.textContent = score;
  }

  // Loop
  function step(ts){
    if (!running) return;
    if (!t0) t0 = ts;
    const dt = (ts - (last||ts))/1000;
    last = ts;

    // timer
    timer -= dt; if (timer<0) timer=0;
    timeEl.textContent = Math.ceil(timer);

    // spawn coins
    spawnAcc += dt;
    const spawnEvery = 0.55; // seconds
    while (spawnAcc >= spawnEvery){
      spawnAcc -= spawnEvery; spawnCoin();
    }

    // input -> velocity
    player.vx = 0;
    if (keys.left) player.vx -= player.speed;
    if (keys.right) player.vx += player.speed;
    player.x += player.vx * dt;
    player.x = Math.max(player.w/2, Math.min(cv.width - player.w/2, player.x));

    // update coins
    for (const c of coins){
      c.y += c.vy * dt;
      if (!c.caught && intersects(c, player)){
        c.caught = true; c.y = cv.height+50; onCatch(c.type);
      } else if (c.y - c.r > cv.height && !c.caught){
        c.caught = true; onMiss(c.type);
      }
    }
    // remove offscreen
    for (let i=coins.length-1;i>=0;i--) if (coins[i].y > cv.height+60) coins.splice(i,1);

    // draw
    ctx.clearRect(0,0,cv.width,cv.height);
    drawBackground();
    drawPlayer();
    coins.forEach(drawCoin);

    // end conditions
    if (score >= 500 || timer <= 0){
      endGame();
      return;
    }
    requestAnimationFrame(step);
  }

  function startGame(){
    // reset
    running = true; t0=0; last=0; timer = 60; score = 0; coins.length=0;
    updateUI(); timeEl.textContent = 60;
    endOverlay.style.display = 'none';
    endVideo.pause(); endVideo.currentTime = 0;
    requestAnimationFrame(step);
  }

  function endGame(){
    running = false;
    // show video overlay and play
    endOverlay.style.display = 'flex';
    // Try to resume playback on mobile user gesture: we already had clicks for buttons
    endVideo.play().catch(()=>{ /* if blocked, user tap will start */ });
  }

  // Controls
  startBtn.addEventListener('click', startGame);

  window.addEventListener('keydown', e=>{
    if (e.key==='ArrowLeft' || e.key==='a') keys.left = true;
    if (e.key==='ArrowRight' || e.key==='d') keys.right = true;
  });
  window.addEventListener('keyup', e=>{
    if (e.key==='ArrowLeft' || e.key==='a') keys.left = false;
    if (e.key==='ArrowRight' || e.key==='d') keys.right = false;
  });

  // Touch buttons
  let leftDown=false, rightDown=false;
  const press = (k, v) => { keys[k]=v; };
  leftBtn.addEventListener('pointerdown', ()=>press('left', true));
  leftBtn.addEventListener('pointerup',   ()=>press('left', false));
  leftBtn.addEventListener('pointerleave',()=>press('left', false));
  rightBtn.addEventListener('pointerdown',()=>press('right', true));
  rightBtn.addEventListener('pointerup',  ()=>press('right', false));
  rightBtn.addEventListener('pointerleave',()=>press('right', false));

  // Tap canvas to (re)play end video if autoplay blocked
  document.getElementById('game').addEventListener('click', ()=>{
    if (!running && endOverlay.style.display==='flex' && endVideo.paused){
      endVideo.play();
    }
  });
})();
</script>
</body>
</html>