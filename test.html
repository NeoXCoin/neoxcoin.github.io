<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jump Runner</title>
  <style>
    html, body { margin: 0; background:#111; color:#fff; font-family: system-ui, Arial; }
    #wrap { max-width: 760px; margin: 0 auto; padding: 12px 16px; }
    canvas { width: 100%; height: auto; background: linear-gradient(#0a0a2a, #1f005c); border:1px solid #333; border-radius: 8px; display:block; }
    .hud { display:flex; justify-content:space-between; margin:8px 0 4px; font-weight:600; }
    .tip { opacity:.7; font-size:14px; }
    button { background:#2e6fff; color:#fff; border:0; padding:8px 12px; border-radius:6px; cursor:pointer;}
  </style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <canvas id="game" width="760" height="260"></canvas>
  <div class="tip">按空白鍵 / 點擊畫面 跳躍（在空中不能二段跳）。</div>
  <div style="margin-top:8px;">
    <button id="restart" hidden>重新開始</button>
  </div>
</div>

<script>
(() => {
  const c = document.getElementById('game');
  const ctx = c.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const restartBtn = document.getElementById('restart');

  let best = Number(localStorage.getItem('runner_best')||0);
  bestEl.textContent = best;

  // 世界設定
  const GROUND_Y = 210;
  const GRAVITY = 0.9;
  const JUMP_VY = -14;

  // 玩家
  const player = { x: 80, y: GROUND_Y, w: 28, h: 32, vy: 0, onGround: true, alive: true };

  // 障礙
  let obstacles = [];
  let spawnTimer = 0;
  let speed = 6;

  // 狀態
  let running = true;
  let score = 0;

  // 輸入
  function jump() {
    if (player.onGround && player.alive) {
      player.vy = JUMP_VY;
      player.onGround = false;
    }
  }
  window.addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); jump(); }});
  c.addEventListener('pointerdown', jump);

  restartBtn.onclick = () => {
    // reset
    obstacles = [];
    spawnTimer = 0;
    speed = 6;
    score = 0;
    player.x = 80; player.y = GROUND_Y; player.vy = 0; player.onGround = true; player.alive = true;
    running = true;
    restartBtn.hidden = true;
    requestAnimationFrame(loop);
  };

  function aabb(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function spawnObstacle() {
    const height = 20 + Math.random()*40; // 20-60
    const width  = 18 + Math.random()*20; // 18-38
    obstacles.push({ x: c.width + 10, y: GROUND_Y + 2 - height, w: width, h: height, passed:false });
  }

  function drawGround() {
    ctx.strokeStyle = 'rgba(255,255,255,.15)';
    ctx.beginPath();
    ctx.moveTo(0, GROUND_Y + 2);
    ctx.lineTo(c.width, GROUND_Y + 2);
    ctx.stroke();
  }

  function drawPlayer() {
    // 簡單的方塊 + 眼睛
    ctx.fillStyle = '#ffd166';
    ctx.fillRect(player.x, player.y - player.h, player.w, player.h);
    ctx.fillStyle = '#111';
    ctx.fillRect(player.x + player.w*0.65, player.y - player.h + 8, 4, 4);
  }

  function drawObstacles() {
    ctx.fillStyle = '#06d6a0';
    for (const o of obstacles) {
      ctx.fillRect(o.x, o.y, o.w, o.h);
    }
  }

  function drawParallax(t) {
    // 背景星點
    ctx.fillStyle = 'rgba(255,255,255,.25)';
    for (let i=0;i<40;i++){
      const sx = (i*97 + (t*0.03)) % c.width;
      const sy = (i*53 % (GROUND_Y-40)) + 20;
      ctx.fillRect(sx, sy, 2, 2);
    }
  }

  let last = performance.now();
  function loop(now) {
    if (!running) return;
    const dt = (now - last) / 16.67; // 相對於 60fps
    last = now;

    // 更新
    ctx.clearRect(0,0,c.width,c.height);
    drawParallax(now);

    // 玩家物理
    player.vy += GRAVITY * dt;
    player.y += player.vy * dt;
    if (player.y >= GROUND_Y) { player.y = GROUND_Y; player.vy = 0; player.onGround = true; }

    // 生成障礙
    spawnTimer -= dt;
    if (spawnTimer <= 0) {
      spawnObstacle();
      spawnTimer = 40/ speed + Math.random()*20/ speed; // 隨速度調節間距
    }

    // 移動障礙 & 計分
    for (const o of obstacles) {
      o.x -= speed * dt * 3.5;
      if (!o.passed && o.x + o.w < player.x) {
        o.passed = true;
        score++;
        scoreEl.textContent = score;
        // 提升難度
        if (score % 5 === 0) speed += 0.6;
      }
    }
    // 清理離場
    obstacles = obstacles.filter(o => o.x + o.w > -20);

    // 碰撞
    const pBox = { x: player.x, y: player.y - player.h, w: player.w, h: player.h };
    for (const o of obstacles) {
      if (aabb(pBox, o)) {
        player.alive = false;
        running = false;
        if (score > best) { best = score; localStorage.setItem('runner_best', best); }
        bestEl.textContent = best;
        restartBtn.hidden = false;
      }
    }

    // 繪圖
    drawGround();
    drawObstacles();
    drawPlayer();

    // 文案
    if (!player.alive) {
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 28px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', c.width/2, 110);
      ctx.font = '16px system-ui, Arial';
      ctx.fillText('按「重新開始」或 R 鍵再玩', c.width/2, 140);
    } else {
      requestAnimationFrame(loop);
    }
  }

  // R 鍵重開
  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase()==='r' && restartBtn.hidden===false) restartBtn.click();
  });

  // 開始
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>