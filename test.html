<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>NeoX Star Dodger</title>
  <style>
    /* —— 基本樣式 —— */
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 50% 30%, #0e1440 0%, #090b24 60%, #050614 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Heiti TC", "PingFang TC", "Noto Sans TC", Arial, sans-serif;
      color: #fff;
      overflow: hidden; /* 避免滾動 */
    }
    #wrap {
      position: relative;
      height: 100%;
      display: grid;
      place-items: center;
    }
    canvas {
      display: block;
      width: min(92vw, 700px);
      height: auto;
      aspect-ratio: 9/16; /* 手機直向比例 */
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(16,18,52,.8), rgba(10,12,34,.9));
      touch-action: none; /* 攔截手勢避免頁面滑動 */
    }
    /* HUD 與按鈕 */
    .hud {
      position: absolute; inset: 0;
      display: grid; grid-template-rows: auto 1fr auto;
      pointer-events: none; /* 預設不吃事件，按鈕各自開啟 */
    }
    .topbar {
      display:flex; justify-content: space-between; align-items:center;
      gap:10px; padding: 10px 14px;
      font-weight: 600; letter-spacing:.3px;
      text-shadow: 0 1px 0 rgba(0,0,0,.5);
    }
    .badge {
      padding:6px 10px; border-radius:10px; background: rgba(255,255,255,.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
    }
    .buttons { display:flex; gap:8px; }
    button {
      pointer-events: auto;
      border:0; border-radius:10px; padding:8px 12px; font-weight:700;
      background: #2b7cff; color:white; cursor:pointer;
      box-shadow: 0 6px 18px rgba(43,124,255,.35);
      transition: transform .06s ease, filter .2s ease;
    }
    button.alt { background: #1f2648; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08); }
    button:active { transform: translateY(1px) scale(.99); filter: brightness(.95); }

    /* 中央訊息面板（開始/結束/暫停） */
    .center {
      display:grid; place-items:center; padding: 10px;
    }
    .panel {
      pointer-events:auto;
      min-width: clamp(240px, 80%, 520px);
      text-align:center; padding: 18px 16px 20px;
      border-radius: 14px;
      background: rgba(10,12,34,.85);
      box-shadow: 0 20px 60px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.06);
      backdrop-filter: blur(4px);
    }
    .panel h1 { margin: 8px 0 6px; font-size: clamp(20px, 4.8vw, 28px); }
    .panel p { margin: 6px 0 14px; color: #b9c1ff; font-size: 14px; line-height: 1.5; }
    .panel .row { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }
    .hidden { display:none !important; }

    /* 觸控區域提示（左右半屏） */
    .touch-hints {
      position: absolute; inset: 0; display:grid; grid-template-columns: 1fr 1fr;
      pointer-events:none; opacity:.1;
    }
    .touch-hints > div { border: 1px dashed rgba(255,255,255,.1); margin: 6px; border-radius: 12px; }
    @media (hover:hover) and (pointer:fine) {
      .touch-hints { display:none; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="450" height="800" aria-label="NeoX Star Dodger"></canvas>

    <!-- HUD -->
    <div class="hud" aria-live="polite">
      <div class="topbar">
        <div class="badge" id="scoreBadge">分數：0</div>
        <div class="buttons">
          <button id="btnPause" class="alt" title="暫停/繼續 (P)">⏸ 暫停</button>
          <button id="btnRestart" title="重新開始 (R)">🔄 重新開始</button>
        </div>
      </div>

      <div class="center">
        <div id="panelStart" class="panel">
          <h1>NeoX Star Dodger</h1>
          <p>左右移動閃避隕石，吃到星星可額外加分。<br>
             鍵盤 <b>← →</b> 或拖曳／點按左右半邊螢幕移動。<br>
             遊戲中可按 <b>P</b> 暫停，<b>R</b> 重開。</p>
          <div class="row">
            <button id="btnStart">▶ 開始遊戲</button>
          </div>
        </div>

        <div id="panelPause" class="panel hidden">
          <h1>暫停中</h1>
          <p>稍作休息。準備好了就繼續吧！</p>
          <div class="row">
            <button id="btnResume">⏵ 繼續</button>
            <button id="btnRestart2" class="alt">🔄 重開</button>
          </div>
        </div>

        <div id="panelGameOver" class="panel hidden">
          <h1>遊戲結束</h1>
          <p><span id="finalScore">分數：0</span><br><span id="bestScore">最佳：0</span></p>
          <div class="row">
            <button id="btnPlayAgain">再來一次</button>
          </div>
        </div>
      </div>

      <!-- 觸控區塊提示（僅行動裝置會看到一點點線框） -->
      <div class="touch-hints" aria-hidden="true">
        <div></div><div></div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // NeoX Star Dodger 主程式
    // =========================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // 為了視網膜螢幕清晰，動態 scale 畫布
    function fitHiDPI() {
      const cssWidth = canvas.clientWidth;
      const cssHeight = canvas.clientHeight;
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      if (canvas.width !== Math.round(cssWidth * dpr)) {
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
      }
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 之後一律用 CSS 尺寸作座標
    }
    fitHiDPI();
    addEventListener('resize', fitHiDPI);

    // —— 遊戲狀態 —— //
    const State = { READY:0, PLAYING:1, PAUSED:2, OVER:3 };
    let gameState = State.READY;

    // 玩家物件
    const player = {
      x: 225, y: 720, r: 14,
      speed: 5.2, vx: 0,
      color1: '#59b1ff', color2: '#2b7cff'
    };

    // 物件池
    const meteors = [];  // 隕石（需閃避）
    const stars = [];    // 星星（可吃）
    let spawnTimer = 0;
    let score = 0;
    let best = Number(localStorage.getItem('neox_dodger_best') || 0);
    const scoreBadge = document.getElementById('scoreBadge');

    // 輸入（鍵盤與觸控）
    const keys = new Set();
    addEventListener('keydown', e => {
      if (e.repeat) return;
      if (e.key === 'ArrowLeft') keys.add('L');
      if (e.key === 'ArrowRight') keys.add('R');
      if (e.key.toLowerCase() === 'p') togglePause();
      if (e.key.toLowerCase() === 'r') restart();
      if (gameState === State.READY && (e.key === ' ' || e.key === 'Enter')) start();
    });
    addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft') keys.delete('L');
      if (e.key === 'ArrowRight') keys.delete('R');
    });

    // 觸控/滑鼠（左右半屏）
    let pointerId = null;
    let pointerX = null;
    function pointerDown(e) {
      const p = (e.changedTouches && e.changedTouches[0]) || e;
      pointerId = p.identifier ?? 'mouse';
      pointerX = p.clientX;
      if (gameState === State.READY) start();
      e.preventDefault();
    }
    function pointerMove(e) {
      const p = (e.changedTouches && ([...e.changedTouches].find(t => (t.identifier ?? 'mouse') === pointerId))) || e;
      if (p && pointerX != null) {
        const rect = canvas.getBoundingClientRect();
        const cx = (p.clientX - rect.left) / rect.width * canvas.clientWidth;
        // 以目標 x 慢慢靠近
        const diff = cx - player.x;
        player.vx = Math.max(-player.speed, Math.min(player.speed, diff * 0.25));
      }
      e.preventDefault();
    }
    function pointerUp(e) { pointerId = null; pointerX = null; player.vx = 0; e.preventDefault(); }

    canvas.addEventListener('pointerdown', pointerDown, {passive:false});
    addEventListener('pointermove', pointerMove, {passive:false});
    addEventListener('pointerup', pointerUp, {passive:false});
    addEventListener('pointercancel', pointerUp, {passive:false});
    addEventListener('blur', () => { if (gameState === State.PLAYING) togglePause(true); });

    // —— UI 面板 —— //
    const panelStart = document.getElementById('panelStart');
    const panelPause = document.getElementById('panelPause');
    const panelOver  = document.getElementById('panelGameOver');
    const finalScore = document.getElementById('finalScore');
    const bestScore  = document.getElementById('bestScore');

    document.getElementById('btnStart').onclick = start;
    document.getElementById('btnPause').onclick = () => togglePause();
    document.getElementById('btnResume').onclick = () => togglePause(false);
    document.getElementById('btnRestart').onclick = restart;
    document.getElementById('btnRestart2').onclick = restart;
    document.getElementById('btnPlayAgain').onclick = restart;

    function show(el, show=true){ el.classList.toggle('hidden', !show); }
    function refreshHUD(){
      scoreBadge.textContent = `分數：${Math.floor(score)}`;
      bestScore.textContent  = `最佳：${Math.floor(best)}`;
      finalScore.textContent = `分數：${Math.floor(score)}`;
    }

    function start(){
      score = 0;
      meteors.length = 0;
      stars.length = 0;
      spawnTimer = 0;
      player.x = canvas.clientWidth/2;
      player.y = canvas.clientHeight*0.9;
      player.vx = 0;
      gameState = State.PLAYING;
      show(panelStart, false);
      show(panelPause, false);
      show(panelOver,  false);
      document.getElementById('btnPause').textContent = '⏸ 暫停';
    }
    function togglePause(forcePause){
      if (gameState === State.PLAYING && (forcePause ?? true)) {
        gameState = State.PAUSED;
        show(panelPause, true);
        document.getElementById('btnPause').textContent = '⏵ 繼續';
      } else if (gameState === State.PAUSED) {
        gameState = State.PLAYING;
        show(panelPause, false);
        document.getElementById('btnPause').textContent = '⏸ 暫停';
      }
    }
    function gameOver(){
      gameState = State.OVER;
      best = Math.max(best, Math.floor(score));
      localStorage.setItem('neox_dodger_best', String(best));
      refreshHUD();
      show(panelOver, true);
    }
    function restart(){
      show(panelOver, false);
      show(panelPause, false);
      start();
    }

    // —— 工具 —— //
    function rand(min, max){ return Math.random()*(max-min)+min; }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
      // 圓形與矩形碰撞
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx + dy*dy) <= r*r;
    }

    // —— 生成物件 —— //
    function spawnEntities(dt){
      spawnTimer -= dt;
      if (spawnTimer <= 0){
        // 難度會隨時間提升
        const level = 1 + Math.min(3, Math.floor(score / 200));
        const meteorCount = 1 + Math.floor(Math.random()*level);
        for (let i=0;i<meteorCount;i++){
          meteors.push({
            x: rand(20, canvas.clientWidth-40), y: -30,
            w: rand(18, 36), h: rand(18, 36),
            vy: rand(2.6, 3.8) + level*0.4,
            rot: rand(0,Math.PI*2), vr: rand(-0.08,0.08)
          });
        }
        // 小機率產生星星
        if (Math.random() < 0.55){
          stars.push({
            x: rand(20, canvas.clientWidth-20), y: -18,
            r: 9, vy: rand(2.4, 3.2) + Math.min(2, score/250)
          });
        }
        spawnTimer = Math.max(0.35, 1.15 - score/200); // 越來越密集
      }
    }

    // —— 更新邏輯 —— //
    let last = performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      fitHiDPI();
      const dt = Math.min(50, now - last) / 16.6667; // 以 60fps 為基準
      last = now;

      // 畫背景星點
      drawBackground(now);

      if (gameState === State.PLAYING){
        // 玩家移動
        player.vx = (keys.has('L') ? -player.speed : 0) + (keys.has('R') ? player.speed : 0) || player.vx*0.92;
        player.x += player.vx;
        player.x = clamp(player.x, player.r+6, canvas.clientWidth - player.r - 6);

        // 產生/更新物件
        spawnEntities(dt);
        for (let m of meteors){ m.y += m.vy * dt; m.rot += m.vr * dt; }
        for (let s of stars){ s.y += s.vy * dt; }

        // 碰撞檢查
        for (let i=meteors.length-1; i>=0; i--){
          const m = meteors[i];
          if (circleRectCollide(player.x, player.y, player.r, m.x, m.y, m.w, m.h)) {
            gameOver();
          }
          if (m.y > canvas.clientHeight + 40) meteors.splice(i,1);
        }
        for (let i=stars.length-1; i>=0; i--){
          const s = stars[i];
          const dx = s.x - player.x, dy = s.y - player.y;
          if (dx*dx + dy*dy <= (s.r + player.r)*(s.r + player.r)) {
            score += 25; // 吃星星加分
            stars.splice(i,1);
          } else if (s.y > canvas.clientHeight + 30) {
            stars.splice(i,1);
          }
        }

        // 分數隨時間增加
        score += 0.9 * dt;
        refreshHUD();
      }

      // 繪製玩家與物件
      drawPlayer();
      drawMeteors();
      drawStars();

      // 提示文字（未開始）
      if (gameState === State.READY){
        tipText('點擊或按空白鍵開始', canvas.clientWidth/2, canvas.clientHeight*0.6);
      }
    }
    requestAnimationFrame(loop);

    // —— 視覺繪製 —— //
    function drawBackground(t){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      // 漸層光暈
      const g = ctx.createRadialGradient(w*0.5, h*0.25, 20, w*0.5, h*0.25, h*0.9);
      g.addColorStop(0, 'rgba(80,110,255,0.10)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      // 星塵點
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      for (let i=0;i<36;i++){
        const x = (t*0.02 + i*97) % w;
        const y = (t*0.06 + i*53) % h;
        ctx.fillRect(x, y, 1, 1);
      }
      ctx.globalAlpha = 1;
    }

    function drawPlayer(){
      const x = player.x, y = player.y, r = player.r;
      // 外圈光暈
      const grad = ctx.createRadialGradient(x, y, 2, x, y, r*2.2);
      grad.addColorStop(0, 'rgba(90,180,255,0.9)');
      grad.addColorStop(1, 'rgba(90,180,255,0)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(x,y,r*2.2,0,Math.PI*2); ctx.fill();

      // 主體漸層球
      const g = ctx.createLinearGradient(x, y-r, x, y+r);
      g.addColorStop(0, player.color1);
      g.addColorStop(1, player.color2);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

      // 亮點
      ctx.fillStyle = 'rgba(255,255,255,.8)';
      ctx.beginPath(); ctx.arc(x-r*0.35, y-r*0.35, r*0.25, 0, Math.PI*2); ctx.fill();
    }

    function drawMeteors(){
      ctx.save();
      for (let m of meteors){
        ctx.translate(m.x + m.w/2, m.y + m.h/2);
        ctx.rotate(m.rot);
        ctx.translate(-m.w/2, -m.h/2);
        // 隕石本體
        ctx.fillStyle = '#6e6f86';
        ctx.fillRect(0,0,m.w,m.h);
        // 邊框
        ctx.strokeStyle = 'rgba(255,255,255,.15)';
        ctx.strokeRect(0,0,m.w,m.h);
        ctx.setTransform(1,0,0,1,0,0);
      }
      ctx.restore();
    }

    function drawStars(){
      for (let s of stars){
        drawStar(s.x, s.y, s.r, 5);
      }
    }
    function drawStar(x, y, r, spikes){
      const outer = r, inner = r*0.5;
      let rot = Math.PI/2*3, cx = x, cy = y;
      ctx.beginPath();
      ctx.moveTo(cx, cy - outer);
      for (let i=0; i<spikes; i++){
        ctx.lineTo(cx + Math.cos(rot)*outer, cy + Math.sin(rot)*outer);
        rot += Math.PI/spikes;
        ctx.lineTo(cx + Math.cos(rot)*inner, cy + Math.sin(rot)*inner);
        rot += Math.PI/spikes;
      }
      ctx.lineTo(cx, cy - outer);
      ctx.closePath();
      ctx.fillStyle = '#ffd76b';
      ctx.shadowColor = '#ffd76b';
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function tipText(text, x, y){
      ctx.font = '600 18px system-ui, -apple-system, "Segoe UI"';
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,255,255,.9)';
      ctx.fillText(text, x, y);
    }

    // 初始 HUD 更新
    refreshHUD();
  </script>
</body>
</html>